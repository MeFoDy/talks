<!DOCTYPE html>
<html lang="ru">

<head>
	<title>Shower Presentation Engine</title>
	<meta charset="utf-8">
	<meta http-equiv="x-ua-compatible"
	      content="ie=edge">
	<meta name="viewport"
	      content="width=device-width, initial-scale=1">
	<link rel="stylesheet"
	      href="shower/themes/ribbon/styles/screen-16x10.css">
	<link rel="stylesheet"
	      href="prism/prism.min.css">
	<link rel="stylesheet"
	      href="styles/style.css">
</head>

<body class="shower list">

	<header class="caption">
		<h1>Houdini — великий разоблачитель</h1>
		<p>
			<a href="https://twitter.com/dark_mefody">Никита Дубко</a>, Capital Decision.
		</p>
	</header>


	<section class="slide clear"
	         id="cover">
		<h2>Houdini — великий разоблачитель</h2>
		<hr>
		<p>
			<a href="https://twitter.com/dark_mefody">Никита Дубко</a>, Capital Decision
		</p>
		<figure>
			<img class="cover"
			     src="pictures/cover.jpg"
			     alt="Hands on the orange typewriter in a park">
			<figcaption class="white">
				<a href="https://pixabay.com/en/vienna-rabbit-hat-magic-witchcraft-358565/">pixabay.com</a>
			</figcaption>
		</figure>

		<style>
			#cover h2 {
				margin: 30px 0 20px;
				font-size: 70px;
			}

			#cover hr {
				border-color: #ccc;
				margin-left: 0;
				width: 300px;
				opacity: 0.5;
			}

			#cover p {
				margin: 0;
				font-size: 20px;
				color: #585a5e;
			}

		</style>
	</section>


	<section class="slide">
		<h2>Конвейер рендеринга в браузере</h2>
		<svg class="render-block">
			<use xlink:href="#nd-render-picture">
		</svg>
		<footer>
			<p>Упрощенно процесс рендеринга страницы в браузере можно разделить на 6 этапов: Parser, DOM/CSSOM, Cascade, Layout, Paint
				и Composite.</p>
		</footer>

		<style>
			.render-block {
				width: 100%;
			}

		</style>
	</section>


	<section class="slide nd-pipeline nd-pipeline-parser">
		<h2>Конвейер рендеринга в браузере</h2>
		<svg class="render-block">
			<use xlink:href="#nd-render-picture">
		</svg>
		<ol>
			<li>Скачивание и парсинг HTML, CSS и JavaScript</li>
		</ol>
		<footer>
			<p>На первом этапе браузер скачивает файлы HTML, CSS и JavaScript. Исходные тексты разбираются и приводятся в исправленный
				и понятный браузеру вид.</p>
		</footer>

		<style>
			.nd-pipeline-parser {
				--nd-render-parse-color: var(--color-active);
			}

		</style>
	</section>


	<section class="slide nd-pipeline nd-pipeline-dom">
		<h2>Конвейер рендеринга в браузере</h2>
		<svg class="render-block">
			<use xlink:href="#nd-render-picture">
		</svg>
		<ol>
			<li class="not-active-item">Скачивание и парсинг HTML, CSS и JavaScript</li>
			<li>Построение Document Object Model и CSS Object Model</li>
		</ol>
		<footer>
			<p>На втором этапе на основе полученного исходного текста формируется два дерева, DOM и CSSOM, причем каждому листу DOM ставится
				в соответствие свой узел CSSOM.</p>
		</footer>

		<style>
			.nd-pipeline-dom {
				--nd-render-parse-color: var(--color-inactive);
				--nd-render-dom-color: var(--color-active);
			}

		</style>
	</section>


	<section class="slide nd-pipeline nd-pipeline-cascade">
		<h2>Конвейер рендеринга в браузере</h2>
		<svg class="render-block">
			<use xlink:href="#nd-render-picture">
		</svg>
		<ol>
			<li class="not-active-item">Скачивание и парсинг HTML, CSS и JavaScript</li>
			<li class="not-active-item">Построение Document Object Model и CSS Object Model</li>
			<li>Формирование дерева рендеринга</li>
		</ol>
		<footer>
			<p>К полученным DOM и CSSOM применяются правила каскада, внутренние правила браузера, и на основании этого формируется render
				tree.
			</p>
		</footer>

		<style>
			.nd-pipeline-cascade {
				--nd-render-parse-color: var(--color-inactive);
				--nd-render-dom-color: var(--color-inactive);
				--nd-render-cascade-color: var(--color-active);
			}

		</style>
	</section>


	<section class="slide nd-pipeline nd-pipeline-layout">
		<h2>Конвейер рендеринга в браузере</h2>
		<svg class="render-block">
			<use xlink:href="#nd-render-picture">
		</svg>
		<ol>
			<li class="not-active-item">Скачивание и парсинг HTML, CSS и JavaScript</li>
			<li class="not-active-item">Построение Document Object Model и CSS Object Model</li>
			<li class="not-active-item">Формирование дерева рендеринга</li>
			<li>Расчет положения на странице каждого элемента дерева рендеринга</li>
		</ol>
		<footer>
			<p>Для каждого элемента render tree рассчитывается его положение на странице в текущий момент времени. При необходимости
				элементы разбиваются на разные слои.</p>
		</footer>

		<style>
			.nd-pipeline-layout {
				--nd-render-parse-color: var(--color-inactive);
				--nd-render-dom-color: var(--color-inactive);
				--nd-render-cascade-color: var(--color-inactive);
				--nd-render-layout-color: var(--color-active);
			}

		</style>
	</section>


	<section class="slide nd-pipeline nd-pipeline-paint">
		<h2>Конвейер рендеринга в браузере</h2>
		<svg class="render-block">
			<use xlink:href="#nd-render-picture">
		</svg>
		<ol>
			<li class="not-active-item">Скачивание и парсинг HTML, CSS и JavaScript</li>
			<li class="not-active-item">Построение Document Object Model и CSS Object Model</li>
			<li class="not-active-item">Формирование дерева рендеринга</li>
			<li class="not-active-item">Расчет положения на странице каждого элемента дерева рендеринга</li>
			<li>Отрисовка пикселей каждого слоя</li>
		</ol>
		<footer>
			<p>На этапе отрисовки каждый слой формирует готовый для отображения в браузере массив пикселей.</p>
		</footer>

		<style>
			.nd-pipeline-paint {
				--nd-render-parse-color: var(--color-inactive);
				--nd-render-dom-color: var(--color-inactive);
				--nd-render-cascade-color: var(--color-inactive);
				--nd-render-layout-color: var(--color-inactive);
				--nd-render-paint-color: var(--color-active);
			}

		</style>
	</section>


	<section class="slide nd-pipeline nd-pipeline-composite">
		<h2>Конвейер рендеринга в браузере</h2>
		<svg class="render-block">
			<use xlink:href="#nd-render-picture">
		</svg>
		<ol>
			<li class="not-active-item">Скачивание и парсинг HTML, CSS и JavaScript</li>
			<li class="not-active-item">Построение Document Object Model и CSS Object Model</li>
			<li class="not-active-item">Формирование дерева рендеринга</li>
			<li class="not-active-item">Расчет положения на странице каждого элемента дерева рендеринга</li>
			<li class="not-active-item">Отрисовка пикселей каждого слоя</li>
			<li>Компоновка слоев и отображение в видимой области браузера</li>
		</ol>
		<footer>
			<p>Отрисованные на каждом слое пиксели компонуются в один общий слой и отображаются на экране.</p>
		</footer>

		<style>
			.nd-pipeline-composite {
				--nd-render-parse-color: var(--color-inactive);
				--nd-render-dom-color: var(--color-inactive);
				--nd-render-cascade-color: var(--color-inactive);
				--nd-render-layout-color: var(--color-inactive);
				--nd-render-paint-color: var(--color-inactive);
				--nd-render-composite-color: var(--color-active);
			}

		</style>
	</section>


	<section class="slide nd-pipeline nd-pipeline-total">
		<h2>Конвейер рендеринга в браузере</h2>
		<svg class="render-block">
			<use xlink:href="#nd-render-picture">
		</svg>
		<ol>
			<li class="not-active-item">Магия</li>
			<li>Можем влиять на процесс из JavaScript</li>
			<li class="not-active-item">Магия</li>
			<li class="not-active-item">Магия</li>
			<li class="not-active-item">Магия</li>
			<li class="not-active-item">Магия</li>
		</ol>
		<footer>
			<p>Из всех шести этапов веб-разработчики могут явно влиять всего на один: построение DOM/CSSOM. По сути, движок рендеринга —
				это «черный ящик», и почти все, что в нем происходит — некая браузерная «магия», основанная на спецификациях W3C.</p>
		</footer>

		<style>
			.nd-pipeline-total {
				--nd-render-parse-color: var(--color-inactive);
				--nd-render-dom-color: lightgreen;
				--nd-render-cascade-color: var(--color-inactive);
				--nd-render-layout-color: var(--color-inactive);
				--nd-render-paint-color: var(--color-inactive);
				--nd-render-composite-color: var(--color-inactive);
			}

		</style>
	</section>


	<section class="slide clear black">
		<img class="cover"
		     src="./pictures/sad.gif"
		     style="width: 100%;">
		<footer>
			<p>Неужели все так плохо?</p>
		</footer>
	</section>


	<section class="slide">
		<h2 class="shout shout-mini">
			<a href="https://extensiblewebmanifesto.org">extensiblewebmanifesto.org</a>
		</h2>
		<footer>
			<p>10 июня 2013 года авторы веб-спецификаций и разработчики из ведущих IT-компаний подписали веб-манифест, который должен
				призвать разработчиков браузеров к более открытому и простому процессу интеграции новых возможностей в производство.</p>
		</footer>
	</section>


	<section class="slide">
		<h2>
			The Extensible Web Manifesto
			<small class="header-note">10.06.2013</small>
		</h2>
		<blockquote>
			<p>Focus on adding new low-level capabilities to the web platform that are secure and efficient.</p>
		</blockquote>
		<blockquote>
			<p>Expose low-level capabilities that explain existing features, such as HTML and CSS, allowing authors to understand and
				replicate them.</p>
		</blockquote>
		<blockquote>
			<p>Simplify and streamline the longer-term process of standardizing new APIs, which will already have implementations and
				significant real-world usage.</p>
		</blockquote>
		<footer>
			<p>Некоторые пункты манифеста связаны с невозможностью явно контролировать конвейер рендеринга в браузерах.</p>
		</footer>
	</section>


	<section class="slide nd-manifesto-rus">
		<h2>The Extensible Web Manifesto
			<small class="header-note">10.06.2013</small>
		</h2>
		<blockquote>
			<p>Сосредоточиться на добавлении новых безопасных и эффективных низкоуровневых возможностей веб-платформы.</p>
		</blockquote>
		<blockquote>
			<p>Раскрывать низкоуровневые возможности, что объяснит существующие функции, такие как HTML и CSS, позволяя авторам понимать
				и воспроизводить их.</p>
		</blockquote>
		<blockquote>
			<p>Упростить и оптимизировать долгосрочный процесс стандартизации новых API, которые будут иметь применение и значительное
				использование в реальных условиях.</p>
		</blockquote>
		<footer>
			<p>Авторы манифеста призывают разработчиков браузеров предоставить доступ к low-level API, чтобы, даже не обладая сложными
				и специфическими знаниями, веб-разработчики могли внедрять новые возможности еще до того, как их начнет нативно поддерживать
				браузер.
			</p>
		</footer>

		<style>
			.nd-manifesto-rus blockquote {
				font-size: 22px;
			}

		</style>
	</section>


	<section class="slide">
		<h2 class="shout">JavaScript</h2>
		<footer>
			<p>Как обстоят дела у JavaScript-разработчиков? Окунемся в историю.</p>
		</footer>
	</section>


	<section class="slide">
		<img src="./pictures/introducing-html5.jpg"
		     class="cover">
		<footer>
			<p>Термин
				<mark>polyfill</mark>
				<a href="https://remysharp.com/2010/10/08/what-is-a-polyfill"></a>появился</a> еще в 2010 году в книге
				<b>Introducing HTML5</b> Брюса Лоусона и Реми Шарпа.</p>
		</footer>
	</section>


	<section class="slide">
		<img src="./pictures/introducing-html5-polyfill-chapter.jpg"
		     class="cover">
		<footer>
			<p>В книге этому термину посвящена целая глава.</p>
		</footer>
	</section>


	<section class="slide nd-polyfill-definition">
		<p>
			<b>Полифилл</b> — это код, реализующий какую-либо функциональность, которая не поддерживается в некоторых версиях веб-браузеров
			по умолчанию.
		</p>
		<style>
			.nd-polyfill-definition {
				font-size: 30px;
			}

			.nd-polyfill-definition p {
				margin-top: 100px;
			}

		</style>
	</section>


	<section class="slide">
		<h2>Polyfill</h2>
		<pre><code class="language-js">(function(self) {
		'use strict';
		if (self.es2020feature) {
			return;
		}
		self.es2020feature = function() {
			// Do some magic
		};
		self.es2020feature.polyfill = true;
	})(this);</code></pre>
		<footer>
			<p>
				Чтобы написать свой polyfill, достаточно применить
				<mark>monkey-patching</mark> к объекту, функциональность которого необходимо расширить. Как правило, разработчики полифиллов
				берут на себя определение наличия нативной реализации функциональности и ее использование.
			</p>
		</footer>
	</section>


	<section class="slide">
		<h2>Ponyfill 🦄</h2>
		<p>
			<a href="ponyfill.com">ponyfill.com</a>
		</p>
		<pre><code class="language-js">// is-nan-ponyfill.js
	module.exports = function (value) {
		return value !== value;
	};

	// app.js
	var isNanPonyfill = require('is-nan-ponyfill');
	isNanPonyfill(5);</code></pre>
		<footer>
			<p>
				Сторонники чистых функций и противники side-эффектов используют другой подход —
				<mark>ponyfill</mark>. Суть его в том, что вместо применения патчей к существующим объектам и классам модуль возвращает чистую
				функцию, которую можно использовать для замещения недостающей функцинальности.
			</p>
		</footer>
	</section>


	<section class="slide">
		<h2>Transpiling</h2>
		<pre><code class="language-js">// ES6
let point = { x: 0, y: 0 };
const {x, y} = point;
const arrowFunction = (a) => a ** 2;

// ES5
"use strict";
var point = { x: 0, y: 0 };
var x = point.x,
    y = point.y;
var arrowFunction = function arrowFunction(a) {
  return Math.pow(a, 2);
};</code></pre>
		<footer>
			<p>
				Когда полифиллов недостаточно, на помощь приходит
				<mark>transpiling</mark> — перевод синтаксиса одного языка в другой. Так новые возможности EcmaScript 6 можно использовать
				даже в очень старых браузерах, прогнав JavaScript-исходники через специальную программу-транспиллер.
			</p>
		</footer>
	</section>


	<section class="slide">
		<img src="./pictures/6to5.png"
		     class="cover"
		     alt="Логотип 6to5">
		<footer>
			<p>
				<a href="https://babeljs.io/blog/2016/12/07/the-state-of-babel">28 сентября 2014 года</a> на Github появился проект
				<mark>6to5</mark>.
			</p>
		</footer>
	</section>


	<section class="slide">
		<img src="./pictures/babel.png"
		     height="290"
		     alt="Логотип Babel"
		     class="cover">
		<footer>
			<p>
				<a href="https://babeljs.io/blog/2015/02/15/not-born-to-die">15 февраля 2015 года</a> разработчики объявили о переименовании
				<mark>6to5</mark> в
				<mark>Babel</mark>. Объединив усилия с разработчиками из Mozilla, The jQuery Foundation, ESLint и др., команда направила силы
				на создание спецификации
				<b>ESTree</b>, которая должна была стать основой для существующих парсеров и инструментов транспиллинга.
			</p>
		</footer>
	</section>


	<section class="slide">
		<img src="./pictures/polymer.png"
		     alt="Polymer logo"
		     class="cover">
		<footer>
			<p>
				Разработчики браузеров тоже не дремлют и активно используют полифиллы, чтобы пропагандировать использование функциональности,
				которой на самом деле в браузере еще нет, но попробовать хочется. Например, в 2012 году разработчики из Google взяли
				веб-компоненты, полифиллы и подарили миру
				<a href="https://www.polymer-project.org">Polymer</a>. К слову, поддержка Shadow DOM и Custom Elements в браузерах до сих пор плачевная.
			</p>
		</footer>
	</section>


	<section class="slide">
		<h2 class="shout">CSS</h2>
		<footer>
			<p>А как обстоят дела у верстальщиков? Бывают ли полифиллы для CSS?</p>
		</footer>
	</section>


	<section class="slide">
		Полифиллы для CSS: препроцессоры, постпроцессоры
	</section>


	<section class="slide">
		polyfill.js
	</section>


	<section class="slide">
		<img class="cover"
		     src="./pictures/houdini-working-group-meeting.jpg"
		     alt=""> CSS-TAG Houdini Task Force
	</section>


	<section class="slide">
		<img src="./pictures/houdini.jpg"
		     alt="Гарри Гудини"
		     height=100>
		<br>Гарри Гудини — не только великий фокусник и иллюзионист, но и разоблачитель "магии".
		<br>проект Houdini — те же цели
	</section>


	<section class="slide nd-houdini-api">
		<figure class="cover">
			<img src="./pictures/houdini-api.png"
			     alt="Новые спецификации Houdini">
			<figcaption>Новые спецификации Houdini для работы с конвейером рендеринга </figcaption>
		</figure>

		<style>
			.nd-houdini-api figcaption {
				text-align: center;
				font-size: 20px;
				font-style: italic;
			}

		</style>
	</section>


	<section class="slide">
		Houdini — коллекция API: список
		<br> https://github.com/w3c/css-houdini-drafts
		<br> https://drafts.css-houdini.org
	</section>


	<section class="slide">
		<h2 class="shout shout-mini">CSS Custom Properties</h2>
	</section>


	<section class="slide">
		<pre><code class="language-css">/* CSS */
:root {
	--r: 255;
	--g: 20;
	--b: 147;
	--deeppink-color: rgb(var(--r), var(--g), var(--b));
}
.pink-element {
	--element-width: 200px;
	--element-border-width: 20px;
	background-color: var(--deeppink-color);
	width: calc(var(--element-width) + var(--element-border-width));
}</code></pre>
	</section>


	<section class="slide">
		<pre><code class="language-js">// JavaScript
const isSupported = CSS.supports('--custom', 'property');

// Получить значение custom property
const pinkElement = document.querySelector('.pink-element');
const elementWidth = window
   .getComputedStyle(pinkElement)
   .getPropertyValue('--element-width');

// Изменить custom property для узла
pinkElement.style.setProperty('--element-width', '300px');

// Изменить custom property в :root
document.documentElement.style.setProperty('--r', 190);</code></pre>
	</section>


	<section class="slide">
		<img src="./pictures/caniuse-custom-properties.jpg"
		     class="cover"
		     alt="Custom Properties — caniuse.com">
	</section>


	<section class="slide slide-codepen clear black">
		<p data-height="100%"
		   data-theme-id="default"
		   data-class="codepen"
		   data-slug-hash="OxgObM"
		   data-default-tab="css,result"
		   data-user="dark_mefody"
		   data-embed-version="2"
		   data-pen-title="#DailyCssImages - Day 17. Zombie"
		   class="codepen cover">See the Pen
			<a href="https://codepen.io/dark_mefody/pen/OxgObM/">#DailyCssImages - Day 17. Zombie</a> by Nikita Dubko (
			<a href="https://codepen.io/dark_mefody">@dark_mefody</a>) on
			<a href="https://codepen.io">CodePen</a>.</p>
		<script async
		        src="https://production-assets.codepen.io/assets/embed/ei.js"></script>
	</section>


	<section class="slide">
		Box Tree API
		<br> описание идеи
	</section>


	<section class="slide">
		CSS Parser API
		<br> https://github.com/WICG/CSS-Parser-API
		<br> Parser API — пока идея. Позволит самостоятельно обрабатывать синтаксическое дерево CSS и превращать его в понятный движку
		CSS. Можно будет добавлять свои директивы, псевдоселекторы, значения свойств (высокопроизводительный PostCSS в браузере).
	</section>


	<section class="slide">
		CSS Typed OM
		<br> https://drafts.css-houdini.org/css-typed-om/
		<br> Как мы обычно задаем стили через JS? Число превращаем в строку, затем подставляем в стили, там оно снова превращается
		в число. Потери тактов процессора и тяжело читаемо. TOM — решает эти проблемы, отделяет типы от значений, позволяет задавать
		и получать данные.
	</section>


	<section class="slide">
		пример кода для CSS Typed OM
	</section>


	<section class="slide">
		полифилл
		<br> https://github.com/css-typed-om/typed-om
	</section>


	<section class="slide">
		<h2 class="center">
			<img src="./pictures/chrome-canary.svg"
			     height="30"> chrome://flags
		</h2>
		<img src="./pictures/experimental-flag.jpg"
		     class="cover"
		     alt="Experimental flag">
	</section>


	<section class="slide">
		Worklets
		<br>https://drafts.css-houdini.org/worklets/
		<br> Worklet — урезанный Worker с ограниченными правами и работающий параллельно основному потоку -> нет доступа к DOM. Решение
		— Proxy. Полифилл к Compositor Worklet (устаревший).
	</section>


	<section class="slide">
		<pre><code>
				window.someWorklet.addModule("someWorklet.js»).then(…);

				registerSomeWorklet(‘someWorkletName’, class {
				   process(arg) {
					  …
				   }
				});</code></pre>
	</section>


	<section class="slide">
		CSS Painting API
		<br> https://drafts.css-houdini.org/css-paint-api/
		<br> https://drafts.css-houdini.org/css-paint-api/EXPLAINER.md
		<br>Paint API. Дает перерисовывать все, где есть image. По сути — облегченный canvas. inputProperties — для оптимизации. Мы
		показываем браузеру, когда нам нужно вызвать paint.
		<br>* background-image
		<br>* border-image
		<br>* list-style-image
		<br>* content
		<br>* НЕ cursor
	</section>


	<section class="slide">
		пример кода для Paint API
		<br>
		<pre><code>class myPaint {
			// Input properties from element to look for
			static get inputProperties() { return ['--foo']; }
			// Input arguments that can be passed to `paint` function
			static get inputArguments() { return ['<color>']; }
			// Alpha allowed?
			// static get alpha() { return true; } // https://github.com/w3c/css-houdini-drafts/commit/869c59a203085c4a1635c225e7cbfc47fc830adc
			static get contextOptions() { return { alpha: true }; }
			paint(ctx, size, props, args) {
			  // ctx - drawing context
			  // size - size of the box being painted
			  // props - inputProperties
			  // args - array of passed-in arguments

			  // Paint code goes here.
			}
		  }</code></pre>
	</section>


	<section class="slide">
		демо 1
		<a href="./demos/1_ripple/index.html">ripple</a>
	</section>


	<section class="slide">
		демо 2
		<a href="./demos/2_border-colors/index.html">border-colors</a>
	</section>


	<section class="slide">
		демо 3
		<a href="./demos/3_border-slicer/index.html">border-slicer</a>
	</section>


	<section class="slide">
		демо 5
		<a href="./demos/5_image-placeholder/index.html">image placeholder</a>
	</section>


	<section class="slide">
		CSS Properties and Values API
		<br> https://drafts.css-houdini.org/css-properties-values-api/
		<br>Как анимировать custom property? (пример: sidebar) Но переменные — это строки. Движок браузера не знает, как их анимировать,
		потому что сложно вычислить разницу в 20% между строкой A и B. Properties and Values API — спасает. На самом деле, это
		всего один метод, который позволяет назначить тип для переменной, дать начальное значение и др.
	</section>


	<section class="slide">
		пример кода для CSS Properties and Values API
		<br>
		<pre><code>.add-my-paint {
				background-image: paint(my-paint);
				--circle-color: blue;
			  }

			  elem.animate([
				{'--circle-color': 'red'},
				{'--circle-color': 'blue'}
			  ], {
				direction: 'alternate', duration: 5000, iterations: 10
			  });</code></pre>
	</section>


	<section class="slide">
		Карта наследования классов CSSStyleValue
	</section>


	<section class="slide">
		демо 4
		<a href="./demos/4_sidebar/index.html">sidebar</a>
	</section>


	<section class="slide">
		CSS Layout API
		<br>Layout API — сложная, но полезная магия. Можно сделать решение на нем, и если оно будет полезным, инженеры браузеров могут
		реализовать это решение на C++ (или на чем написано движок браузера), чтобы сделать это решение более производительным.
	</section>


	<section class="slide">
		пример кода для CSS Layout API
	</section>


	<section class="slide">
		<h2 class="shout shout-mini">display: layout(hexagon);
			<br>
			<a href="./demos/6_hexagon-layout/">демо</a>
		</h2>
	</section>


	<section class="slide">
		Animation API
		<br> https://github.com/web-animations/web-animations-js
	</section>


	<section class="slide">
		Animation Worklet
		<br> https://github.com/WICG/animation-worklet
		<br>https://github.com/GoogleChromeLabs/houdini-samples/tree/master/animation-worklet
		<br> Анимации, привязанные к scroll — большая дыра в производительности. Текущее решение: если элемент находится на отдельном
		слое (will-change), то процессор GPU только вычислит его изменения и сделает merge слоев вместо полной перерисовки всего
		большого слоя. Но 60FPS все равно тяжело достичь.
	</section>


	<section class="slide">
		пример кода Animation Worklet
		<br>http://dassur.ma/things/animworklet/
	</section>


	<section class="slide">
		демо Animation Worklet
	</section>


	<section class="slide">
		Font Metrics API
		<br> Font Metrics API — позволит вычислять различные метрики шрифтов, к которым на данный момент доступа нет. Как посчитать
		точную ширину текста? А если он не помещается в ширину окна?
	</section>


	<section class="slide">
		Почему houdini хорош?
		<br>http://bfgeek.com/houdini/2015/09/14/the-performance-of-houdini-paint/
		<br> * производительность
		<br> * оптимизации
		<br> * эргономичность
	</section>


	<section class="slide">
		Недостатки:
		<br> так как ворклеты загружаются асинхронно, то они не блокируют рендеринг. Поэтому здесь, как у шрифтов, появляется моргание
		при отрисовке. Как будут решать проблему — пока неизвестно.
		<br> пока не работает.
		<br> сложность кода, верстальщикам нужно будет учить еще и все эти API.
	</section>


	<section class="slide">
		Почему стоит попробовать уже сейчас?
		<br>* когда включат - уже будет навык
		<br>* возможность повлиять на спецификацию
		<br>* ценность на рынке труда
	</section>


	<section class="slide">
		Как долго ждать?
		<br> * часть уже реализована в Canary и за флагами в Chrome
		<br> * Layout API - в конце 2017 (https://www.youtube.com/watch?v=RNkwDR1o4u0)
		<br> * все API сильно зависят друг от друга
	</section>


	<section class="slide">
		Что с другими браузерами?
		<br> http://ishoudinireadyyet.com
	</section>


	<section class="slide nd-materials">
		<h2>Материалы по теме</h2>
		<p class="list-header">Статьи</p>
		<ol>
			<li>
				<a href="https://www.smashingmagazine.com/2016/03/houdini-maybe-the-most-exciting-development-in-css-youve-never-heard-of/">Houdini: Maybe The Most Exciting Development In CSS You’ve Never Heard Of</a>
				by Philip Walton
			</li>
			<li>
				<a href="https://developers.google.com/web/updates/2016/05/houdini">Houdini: Demystifying CSS</a>
				by Alex Surma
			</li>
		</ol>
		<p class="list-header">Видео</p>
		<ol>
			<li>
				<a href="https://www.youtube.com/watch?v=sE3ttkP15f8">Houdini: Demystifying the Future of CSS</a>
				— Google I/O 2016
			</li>
			<li>
				<a href="https://vimeo.com/232982766">Philip Walton | Polyfills & Houdini | Browser API Special</a>
				— CSS Day 2017
			</li>
			<li>
				<a href="https://www.youtube.com/watch?v=66E0_QFnmlA">Serg Hospodarets: CSS Houdini - from CSS variables to JavaScript and back</a>
				— Frontend United 2017
			</li>
			<li>
				<a href="https://www.youtube.com/watch?v=RNkwDR1o4u0">Magic Tricks with CSS Houdini (Sam Richard)</a>
				— Full Stack Fest 2017
			</li>
		</ol>

		<style>
			.nd-materials ol {
				font-size: 19px;
			}

		</style>
	</section>


	<svg xmlns="http://www.w3.org/2000/svg"
	     style="display: none;">
		<symbol id="nd-render-picture"
		        viewbox="0 0 800 100">
			<style>
				.nd-render-block {
					fill-opacity: null;
					stroke-opacity: null;
					stroke: #000;
				}

				.nd-render-text {
					stroke-width: 0;
				}

				.nd-render-path {
					fill: #fff;
					stroke-width: 2;
				}

			</style>
			<g class="nd-render-block">
				<path style="fill: var(--nd-render-parse-color)"
				      d="M47.8 13.9h107.2l35.8 35.8-35.8 35.8H47.8L83.6 49.8 47.8 13.9z"
				      class="nd-render-path" />
				<text class="nd-render-text"
				      x="100.1"
				      y="55.6"
				      font-size="17">Parser</text>
			</g>
			<g class="nd-render-block">
				<path style="fill: var(--nd-render-dom-color)"
				      d="M161.8 13.9h107.3l35.8 35.8-35.7 35.8H161.8l35.8-35.8-35.7-35.8z"
				      class="nd-render-path" />
				<text class="nd-render-text"
				      x="213"
				      y="45.6"
				      font-size="17">DOM &#x2F;</text>
				<text class="nd-render-text"
				      x="204.1"
				      y="66.6"
				      font-size="17">CSSOM</text>
			</g>
			<g class="nd-render-block">
				<path style="fill: var(--nd-render-cascade-color)"
				      d="M274.9 13.9h107.2l35.8 35.8-35.8 35.8H274.9l35.8-35.8-35.7-35.8z"
				      class="nd-render-path" />
				<text class="nd-render-text"
				      x="319.3"
				      y="55.6"
				      font-size="17">Cascade</text>
			</g>
			<g class="nd-render-block">
				<path style="fill: var(--nd-render-layout-color)"
				      d="M387.9 13.9h107.2l35.8 35.8-35.8 35.8H387.9l35.8-35.8-35.7-35.8z"
				      class="nd-render-path" />
				<text class="nd-render-text"
				      x="440.3"
				      y="55.6"
				      font-size="17">Layout</text>
			</g>
			<g class="nd-render-block">
				<path style="fill: var(--nd-render-paint-color)"
				      d="M501 13.9H608.2l35.8 35.8-35.8 35.8H501l35.8-35.8-35.7-35.8z"
				      class="nd-render-path" />
				<text class="nd-render-text"
				      x="556.4"
				      y="55.6"
				      font-size="17">Paint</text>
			</g>
			<g class="nd-render-block">
				<path style="fill: var(--nd-render-composite-color)"
				      d="M614 13.9h107.2l35.8 35.8-35.8 35.8H614l35.8-35.8-35.7-35.8z"
				      class="nd-render-path" />
				<text class="nd-render-text"
				      x="656.4"
				      y="55.6"
				      font-size="17">Composite</text>
			</g>
		</symbol>
	</svg>



	<footer class="badge">
		<a href="https://github.com/shower/shower">Powered by Shower</a>
	</footer>

	<div class="progress"></div>

	<script src="shower/shower.min.js"></script>
	<script src="prism/prism.min.js"></script>

</body>

</html>
